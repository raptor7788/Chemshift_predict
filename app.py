import torch
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from torch_geometric.utils import from_smiles
from torch_geometric.nn import AttentiveFP, GCNConv
from torch_geometric.nn import global_mean_pool, global_max_pool, global_add_pool
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from typing import List, Dict, Tuple, Optional

# ËÆæÁΩÆÈ°µÈù¢ÈÖçÁΩÆ
st.set_page_config(
    page_title="Chemical Shift Prediction",
    page_icon="üß™",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Ëá™ÂÆö‰πâCSSÊ†∑Âºè
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        padding: 2rem;
        border-radius: 15px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .feature-card {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        padding: 1.5rem;
        border-radius: 12px;
        border-left: 4px solid #667eea;
        margin: 1rem 0;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }

    .result-card {
        background: white;
        padding: 1.5rem;
        border-radius: 12px;
        border: 1px solid #e1e5e9;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        transition: transform 0.2s ease;
    }

    .result-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.12);
    }

    .metric-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        border-radius: 10px;
        text-align: center;
        margin: 0.5rem 0;
    }

    .plot-controls {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 12px;
        border: 1px solid #dee2e6;
        margin: 1rem 0;
    }

    .success-alert {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #28a745;
        margin: 1rem 0;
    }

    .warning-alert {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
        margin: 1rem 0;
    }

    .info-alert {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #17a2b8;
        margin: 1rem 0;
    }

    .stButton > button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 25px;
        padding: 0.75rem 2rem;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
    }

    .stButton > button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
    }

    .sidebar .stSelectbox > div > div {
        background-color: #f8f9fa;
        border-radius: 8px;
    }

    .compound-title {
        color: #2c3e50;
        font-size: 1.2rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #667eea;
    }

    .prediction-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #2c3e50;
    }

    .model-badge {
        display: inline-block;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 0.3rem 0.8rem;
        border-radius: 15px;
        font-size: 0.8rem;
        font-weight: 500;
        margin: 0.2rem;
    }
</style>
""", unsafe_allow_html=True)


# Load and cache the database
@st.cache_data
def load_database():
    """Load the phosphorus database"""
    try:
        df = pd.read_csv("Resources/phosphorus_O5.csv")
        if 'cansmi' in df.columns:
            df['smiles'] = df['cansmi']
        return df
    except FileNotFoundError:
        st.error("Êï∞ÊçÆÂ∫ìÊñá‰ª∂ 'Resources/phosphorus_O5.csv' Êú™ÊâæÂà∞")
        return None
    except Exception as e:
        st.error(f"Âä†ËΩΩÊï∞ÊçÆÂ∫ìÊó∂Âá∫Èîô: {str(e)}")
        return None


def search_database(smiles_list, database):
    """Search for SMILES in the database"""
    if database is None:
        return {}

    found_results = {}
    for smiles in smiles_list:
        matches = database[database['cansmi'] == smiles]
        if not matches.empty:
            match = matches.iloc[0]
            found_results[smiles] = {
                'shift': match['shift'],
                'solvent': match.get('LM', 'Unknown'),
                'num': match.get('num', ''),
                'MW': match.get('MW', ''),
                'envlab': match.get('envlab', ''),
                'P_oxidation_state': match.get('P_oxidation_state', ''),
                'P_valence': match.get('P_valence', '')
            }
    return found_results


# Load the models
@st.cache_resource
def load_attentivefp_model():
    model = AttentiveFP(
        in_channels=9,
        hidden_channels=66,
        out_channels=1,
        edge_dim=3,
        num_layers=5,
        num_timesteps=3,
        dropout=0.0446259777448801
    )
    model.load_state_dict(
        torch.load("Resources/AttentiveFP_model.pt", map_location=torch.device("cpu"), weights_only=True))
    model.eval()
    return model


class NMRShiftModel(torch.nn.Module):
    def __init__(
            self,
            in_channels=9,
            hidden_channels=185,
            num_layers=4,
            out_channels=1,
            dropout=0.11080081715730111,
            pooling_method='max',
            act='relu',
            jk='cat'
    ):
        super().__init__()
        from torch_geometric.nn import GCN
        self.gcn = GCN(
            in_channels=in_channels,
            hidden_channels=hidden_channels,
            num_layers=num_layers,
            out_channels=hidden_channels,
            dropout=dropout,
            norm='batch_norm',
            jk=jk,
            act=act
        )
        self.lin = torch.nn.Linear(hidden_channels, out_channels)
        self.pooling_method = pooling_method

    def forward(self, x, edge_index, batch):
        x = self.gcn(x, edge_index)
        if self.pooling_method == 'mean':
            x = global_mean_pool(x, batch)
        elif self.pooling_method == 'add':
            x = global_add_pool(x, batch)
        elif self.pooling_method == 'max':
            x = global_max_pool(x, batch)
        x = self.lin(x)
        return x


@st.cache_resource
def load_gcn_model():
    model = NMRShiftModel(
        in_channels=9,
        hidden_channels=185,
        num_layers=4,
        out_channels=1,
        dropout=0.11080081715730111,
        pooling_method='max',
        act='relu',
        jk='cat'
    )
    model.load_state_dict(
        torch.load("Resources/GCN_model.pt", map_location=torch.device("cpu"), weights_only=True))
    model.eval()
    return model


def inverse_transform(scaled_value):
    center = 23.47
    scale = 22.69999886
    return scaled_value * scale + center


def predict_chemical_shift_single_model(smiles_list, model_type='attentivefp'):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    if model_type == 'attentivefp':
        model = load_attentivefp_model().to(device)
    else:
        model = load_gcn_model().to(device)

    predictions = []
    raw_predictions = []
    for smile in smiles_list:
        try:
            g = from_smiles(smile)
            g.x = g.x.float()
            g = g.to(device)
            g.batch = torch.zeros(g.num_nodes, dtype=torch.long, device=device)
            with torch.no_grad():
                if model_type == 'attentivefp':
                    pred = model(g.x, g.edge_index, g.edge_attr, g.batch)
                else:
                    pred = model(g.x, g.edge_index, g.batch)
            raw_pred = pred.item()
            raw_predictions.append(raw_pred)
            actual_pred = inverse_transform(raw_pred)
            predictions.append(actual_pred)
        except Exception as e:
            predictions.append(f"Error: {str(e)}")
            raw_predictions.append(None)
    return predictions, raw_predictions


def predict_with_multiple_models(smiles_list, selected_models=['attentivefp'], database=None):
    results = []
    db_results = search_database(smiles_list, database)
    found_smiles = list(db_results.keys())
    not_found_smiles = [s for s in smiles_list if s not in found_smiles]
    ml_predictions = {}

    for model_type in selected_models:
        if not_found_smiles:
            predictions, raw_predictions = predict_chemical_shift_single_model(not_found_smiles, model_type)
            ml_predictions[model_type] = {
                'predictions': dict(zip(not_found_smiles, predictions)),
                'raw_predictions': dict(zip(not_found_smiles, raw_predictions))
            }

    for smiles in smiles_list:
        if smiles in db_results:
            db_data = db_results[smiles]
            result = {
                'smiles': smiles,
                'database': db_data['shift'],
                'source': 'database',
                'solvent': db_data['solvent'],
                'additional_info': {
                    'num': db_data['num'],
                    'MW': db_data['MW'],
                    'envlab': db_data['envlab'],
                    'P_oxidation_state': db_data['P_oxidation_state'],
                    'P_valence': db_data['P_valence']
                }
            }
            for model_type in selected_models:
                result[f'{model_type}_prediction'] = None
                result[f'{model_type}_raw'] = None
        else:
            result = {
                'smiles': smiles,
                'database': None,
                'source': 'ml_models',
                'solvent': 'N/A',
                'additional_info': {}
            }
            for model_type in selected_models:
                if model_type in ml_predictions:
                    result[f'{model_type}_prediction'] = ml_predictions[model_type]['predictions'].get(smiles, "Error")
                    result[f'{model_type}_raw'] = ml_predictions[model_type]['raw_predictions'].get(smiles, None)
                else:
                    result[f'{model_type}_prediction'] = None
                    result[f'{model_type}_raw'] = None
        results.append(result)
    return results


def create_enhanced_nmr_plot(results: List[Dict], selected_models: List[str],
                             use_database: bool = False, plot_config: Dict = None) -> go.Figure:
    """ÂàõÂª∫Â¢ûÂº∫ÁöÑNMRË∞±ÂõæÔºå‰ºòÂåñÂèØËØªÊÄßÂíå‰∫§‰∫íÊÄß"""
    import plotly.graph_objects as go
    import numpy as np

    if plot_config is None:
        plot_config = {
            'peak_width': 0.04,
            'show_annotations': True,
            'plot_style': 'professional',
            'color_scheme': 'default'
        }

    # Êî∂ÈõÜÊâÄÊúâÊúâÊïàÁöÑÂåñÂ≠¶‰ΩçÁßªÊï∞ÊçÆ
    all_shifts = []
    plot_data = []

    # Áªü‰∏ÄÁöÑÈ¢úËâ≤ÊñπÊ°à - ‰∏éÂØπÊØîÂõæ‰øùÊåÅ‰∏ÄËá¥
    colors = {
        'attentivefp': '#1f77b4',  # Êòé‰∫ÆËìùËâ≤
        'gcn': '#ff7f0e',         # Êòé‰∫ÆÊ©ôËâ≤
        'database': '#2ca02c'      # Êòé‰∫ÆÁªøËâ≤
    }

    for i, result in enumerate(results):
        compound_id = f"ÂåñÂêàÁâ© {i + 1}"

        # Êï∞ÊçÆÂ∫ìÊï∞ÊçÆ
        if use_database and result.get('database') is not None:
            try:
                db_shift = float(result['database'])
                if -200 <= db_shift <= 200:
                    all_shifts.append(db_shift)
                    plot_data.append({
                        'compound': compound_id,
                        'shift': db_shift,
                        'type': 'Êï∞ÊçÆÂ∫ìÂÆûÈ™åÂÄº',
                        'model': 'database',
                        'smiles': result['smiles'],
                        'solvent': result.get('solvent', 'N/A'),
                        'color': colors['database']
                    })
            except (ValueError, TypeError):
                pass

        # Ê®°ÂûãÈ¢ÑÊµãÊï∞ÊçÆ
        for model in selected_models:
            pred_key = f'{model}_prediction'
            if result.get(pred_key) is not None:
                try:
                    pred_shift = float(result[pred_key])
                    if -200 <= pred_shift <= 200:
                        all_shifts.append(pred_shift)
                        plot_data.append({
                            'compound': compound_id,
                            'shift': pred_shift,
                            'type': f'{model.upper()}È¢ÑÊµã',
                            'model': model,
                            'smiles': result['smiles'],
                            'solvent': 'DLÈ¢ÑÊµã',
                            'color': colors.get(model, '#d62728')  # ÈªòËÆ§Á∫¢Ëâ≤
                        })
                except (ValueError, TypeError):
                    pass

    if not all_shifts:
        return None

    # ÂàõÂª∫ÂõæÂΩ¢
    fig = go.Figure()

    # ËÆæÁΩÆXËΩ¥ËåÉÂõ¥
    min_shift = min(all_shifts) - 10
    max_shift = max(all_shifts) + 10
    x_range = np.linspace(min_shift, max_shift, 2000)

    # Ê∑ªÂä†Âü∫Á∫ø
    baseline_y = np.zeros_like(x_range)
    fig.add_trace(go.Scatter(
        x=x_range, y=baseline_y,
        mode='lines',
        line=dict(color='#333333', width=2),
        showlegend=False,
        hoverinfo='skip'
    ))

    # ÁîüÊàêÂ≥∞ÂΩ¢Âπ∂Ê∑ªÂä†Âà∞Âõæ‰∏≠
    compounds = list(set([d['compound'] for d in plot_data]))
    legend_added = set()

    for compound in compounds:
        compound_data = [d for d in plot_data if d['compound'] == compound]

        for j, data in enumerate(compound_data):
            # ÁîüÊàêÊ¥õ‰º¶ÂÖπÂ≥∞
            peak_center = data['shift']
            peak_width = plot_config['peak_width']
            peak_height = 1.0 - j * 0.1  # ‰∏çÂêåÁ±ªÂûãÁöÑÂ≥∞‰ΩøÁî®‰∏çÂêåÈ´òÂ∫¶

            gamma = peak_width / 2
            y_peak = peak_height / (1 + ((x_range - peak_center) / gamma) ** 2)

            # Ê∑ªÂä†Â≥∞ÂΩ¢Êõ≤Á∫ø
            fig.add_trace(go.Scatter(
                x=x_range, y=y_peak,
                mode='lines',
                fill='tonexty' if j == 0 else None,
                line=dict(color=data['color'], width=2.5),
                fillcolor=f"rgba({int(data['color'][1:3], 16)}, {int(data['color'][3:5], 16)}, {int(data['color'][5:7], 16)}, 0.2)",
                name=data['type'] if data['type'] not in legend_added else '',
                showlegend=data['type'] not in legend_added,
                hovertemplate=f"<b>{data['compound']}</b><br>" +
                              f"{data['type']}: <b>{peak_center:.2f} ppm</b><br>" +
                              f"SMILES: {data['smiles'][:40]}{'...' if len(data['smiles']) > 40 else ''}<br>" +
                              f"Ê∫∂ÂâÇ: {data['solvent']}<br>" +
                              "<extra></extra>"
            ))
            legend_added.add(data['type'])

            # Ê∑ªÂä†Â≥∞‰ΩçÊ†áÊ≥®
            if plot_config['show_annotations']:
                fig.add_annotation(
                    x=peak_center,
                    y=peak_height + 0.15,
                    text=f"<b>{peak_center:.1f}</b>",
                    showarrow=True,
                    arrowhead=2,
                    arrowsize=1,
                    arrowwidth=2,
                    arrowcolor=data['color'],
                    font=dict(size=11, color=data['color'], family="Arial Black"),
                    bgcolor="rgba(255,255,255,0.9)",
                    bordercolor=data['color'],
                    borderwidth=2,
                    borderpad=3
                )

    # Êõ¥Êñ∞Â∏ÉÂ±Ä - ‰øÆÂ§çÂõæ‰æãÂèØËßÅÊÄßÈóÆÈ¢ò
    fig.update_layout(
        title=dict(
            text="<b>¬≥¬πP NMR ÂåñÂ≠¶‰ΩçÁßªË∞±Âõæ</b>",
            font=dict(size=24, color='#2c3e50', family="Arial Black"),
            x=0.5,
            y=0.95
        ),
        xaxis=dict(
            title="<b>ÂåñÂ≠¶‰ΩçÁßª (ppm)</b>",
            titlefont=dict(size=16, color='#2c3e50', family="Arial"),
            tickfont=dict(size=14, color='#2c3e50'),
            autorange='reversed',  # NMR‰π†ÊÉØÔºö‰ªéÂè≥Âà∞Â∑¶
            showgrid=True,
            gridwidth=1,
            gridcolor='rgba(128,128,128,0.3)',
            showline=True,
            linewidth=3,
            linecolor='#2c3e50',
            mirror=True,
            range=[max_shift, min_shift],
            zeroline=False,
            tick0=0,
            dtick=20  # ÊØè20ppm‰∏Ä‰∏™‰∏ªÂàªÂ∫¶
        ),
        yaxis=dict(
            title="<b>Áõ∏ÂØπÂº∫Â∫¶</b>",
            titlefont=dict(size=16, color='#2c3e50', family="Arial"),
            tickfont=dict(size=14, color='#2c3e50'),
            showgrid=True,
            gridwidth=1,
            gridcolor='rgba(128,128,128,0.3)',
            showline=True,
            linewidth=3,
            linecolor='#2c3e50',
            mirror=True,
            range=[-0.15, 1.4],
            zeroline=True,
            zerolinewidth=2,
            zerolinecolor='#333333'
        ),
        plot_bgcolor='white',
        paper_bgcolor='white',
        font=dict(family="Arial, sans-serif", color='#2c3e50'),
        # ‰øÆÂ§çÂõæ‰æãÂèØËßÅÊÄßÈóÆÈ¢ò
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.02,
            bgcolor="white",  # ÂÆåÂÖ®‰∏çÈÄèÊòéÁöÑÁôΩËâ≤ËÉåÊôØ
            bordercolor="black",  # ÈªëËâ≤ËæπÊ°ÜÊõ¥ÊòéÊòæ
            borderwidth=3,  # Âä†Á≤óËæπÊ°Ü
            font=dict(
                size=16,  # Êõ¥Â§ßÂ≠ó‰Ωì
                color="black",  # ÊòéÁ°ÆÁöÑÈªëËâ≤Â≠ó‰Ωì
                family="Arial Black, Arial, sans-serif"  # Á≤ó‰ΩìÂ≠ó‰Ωì
            ),
            itemsizing="constant",
            itemwidth=40,  # Â¢ûÂä†Âõæ‰æãÈ°πÂÆΩÂ∫¶
            itemclick="toggleothers",  # ÊîπÂñÑ‰∫§‰∫íÊÄß
            itemdoubleclick="toggle"
        ),
        width=1000,
        height=600,
        margin=dict(l=80, r=200, t=100, b=80)  # Â¢ûÂä†Âè≥ËæπË∑ù‰∏∫Âõæ‰æãÁïôÂá∫Á©∫Èó¥
    )

    return fig


def create_comparison_visualization_force_visible(results: List[Dict], selected_models: List[str],
                                                  use_database: bool = False) -> go.Figure:
    """ÂàõÂª∫Ê®°ÂûãÂØπÊØîÂèØËßÜÂåñÂõæË°® - Âº∫Âà∂ÂèØËßÅÂõæ‰æã"""
    import plotly.express as px
    import pandas as pd
    import plotly.graph_objects as go

    comparison_data = []
    for i, result in enumerate(results):
        compound_id = f"ÂåñÂêàÁâ© {i + 1}"

        # Êî∂ÈõÜÊâÄÊúâÈ¢ÑÊµãÂÄº
        values = {}
        if use_database and result.get('database') is not None:
            try:
                values['Êï∞ÊçÆÂ∫ìÂÆûÈ™åÂÄº'] = float(result['database'])
            except (ValueError, TypeError):
                pass

        for model in selected_models:
            pred_key = f'{model}_prediction'
            if result.get(pred_key) is not None:
                try:
                    values[f'{model.upper()}È¢ÑÊµã'] = float(result[pred_key])
                except (ValueError, TypeError):
                    pass

        for method, value in values.items():
            comparison_data.append({
                'compound': compound_id,
                'method': method,
                'shift': value,
                'smiles': result['smiles']
            })

    if not comparison_data:
        return None

    df = pd.DataFrame(comparison_data)

    # Áªü‰∏ÄÁöÑÈ¢úËâ≤ÊñπÊ°à - ‰∏éNMRË∞±Âõæ‰øùÊåÅ‰∏ÄËá¥
    colors = {
        'ATTENTIVEFPÈ¢ÑÊµã': '#1f77b4',  # Êòé‰∫ÆËìùËâ≤
        'GCNÈ¢ÑÊµã': '#ff7f0e',         # Êòé‰∫ÆÊ©ôËâ≤
        'Êï∞ÊçÆÂ∫ìÂÆûÈ™åÂÄº': '#2ca02c'      # Êòé‰∫ÆÁªøËâ≤
    }

    fig = go.Figure()

    for method in df['method'].unique():
        method_data = df[df['method'] == method]
        fig.add_trace(go.Bar(
            name=method,
            x=method_data['compound'],
            y=method_data['shift'],
            marker_color=colors.get(method, '#d62728'),  # ÈªòËÆ§Á∫¢Ëâ≤
            hovertemplate='<b style="color: #000000;">%{x}</b><br>' +
                          f'<span style="color: #000000; font-weight: bold;">{method}: %{{y:.2f}} ppm</span><br>' +
                          '<extra></extra>',
            hoverlabel=dict(
                bgcolor="white",
                bordercolor="black",
                font_size=14,
                font_color="black"
            )
        ))

    fig.update_layout(
        title=dict(
            text="<b>‰∏çÂêåÊñπÊ≥ïÁöÑÂåñÂ≠¶‰ΩçÁßªÈ¢ÑÊµãÂØπÊØî</b>",
            font=dict(size=20, color='#000000'),
            x=0.5
        ),
        xaxis=dict(
            title="<b>ÂåñÂêàÁâ©</b>",
            titlefont=dict(size=14, color='#000000'),
            tickangle=45,
            tickfont=dict(size=12, color='#000000')
        ),
        yaxis=dict(
            title="<b>ÂåñÂ≠¶‰ΩçÁßª (ppm)</b>",
            titlefont=dict(size=14, color='#000000'),
            tickfont=dict(size=12, color='#000000')
        ),
        margin=dict(r=80, t=100),  # Âè≥ËæπË∑ù
        plot_bgcolor='white',
        paper_bgcolor='white',
        barmode='group',
        height=600,
        font=dict(family="Arial, sans-serif", color='#000000'),
        # ‰ΩøÁî®ÈªòËÆ§Âõæ‰æã - ÊîæÁΩÆÂú®ÂõæË°®ÂÜÖÈÉ®
        showlegend=True,
        legend=dict(
            x=0.7,  # Âõæ‰æã‰ΩçÁΩÆÂú®ÂõæË°®ÂÜÖÈÉ®
            y=0.95,
            bgcolor="white",  # ÂÆåÂÖ®‰∏çÈÄèÊòéÁöÑÁôΩËâ≤ËÉåÊôØ
            bordercolor="black",
            borderwidth=2,  # Âä†Á≤óËæπÊ°Ü
            font=dict(
                size=16,  # Êõ¥Â§ßÂ≠ó‰Ωì
                color="black",  # ÊòéÁ°ÆÈªëËâ≤
                family="Arial Black, Arial, sans-serif"  # ‰ΩøÁî®Á≤ó‰ΩìÂ≠ó‰Ωì
            ),
            itemsizing="constant",  # Âõ∫ÂÆöÂõæ‰æãÈ°πÂ§ßÂ∞è
            itemwidth=30  # Â¢ûÂä†Âõæ‰æãÈ°πÂÆΩÂ∫¶
        ),
        # Ê∑ªÂä†ÁΩëÊ†ºÁ∫ø
        xaxis_showgrid=True,
        yaxis_showgrid=True,
        xaxis_gridcolor='lightgray',
        yaxis_gridcolor='lightgray'
    )

    return fig






# ‰∏ªÂ∫îÁî®Á®ãÂ∫è
def main():
    # È°µÈù¢Ê†áÈ¢ò
    st.markdown("""
    <div class="main-header">
        <h1>üß™ ÂåñÂ≠¶‰ΩçÁßªÈ¢ÑÊµãÂπ≥Âè∞</h1>
        <p>Âü∫‰∫éÂõæÁ•ûÁªèÁΩëÁªúÁöÑ¬≥¬πP NMRÂåñÂ≠¶‰ΩçÁßªÊô∫ËÉΩÈ¢ÑÊµãÁ≥ªÁªü</p>
    </div>
    """, unsafe_allow_html=True)

    # Âä†ËΩΩÊï∞ÊçÆÂ∫ì
    database = load_database()

    # ‰æßËæπÊ†è
    with st.sidebar:
        st.markdown("### üéõÔ∏è ÊéßÂà∂Èù¢Êùø")

        # Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
        if database is not None:
            st.markdown(f"""
            <div class="success-alert">
                ‚úÖ Êï∞ÊçÆÂ∫ìÂ∑≤Âä†ËΩΩ<br>
                üìä ÂåÖÂê´ <strong>{len(database)}</strong> Êù°ËÆ∞ÂΩï
            </div>
            """, unsafe_allow_html=True)
        else:
            st.markdown("""
            <div class="warning-alert">
                ‚ö†Ô∏è Êï∞ÊçÆÂ∫ìÂä†ËΩΩÂ§±Ë¥•
            </div>
            """, unsafe_allow_html=True)

        st.markdown("---")

        # È¢ÑÊµãÊñπÊ≥ïÈÄâÊã©
        st.markdown("### üî¨ È¢ÑÊµãÊñπÊ≥ï")
        use_database = st.checkbox("üóÉÔ∏è Êï∞ÊçÆÂ∫ìÊü•Êâæ", value=True, help="‰ºòÂÖà‰ªéÂÆûÈ™åÊï∞ÊçÆÂ∫ìÊü•Êâæ")

        st.markdown("**Êú∫Âô®Â≠¶‰π†Ê®°ÂûãÔºö**")
        use_attentivefp = st.checkbox("üß† AttentiveFP", value=True, help="Ê≥®ÊÑèÂäõÊú∫Âà∂ÂõæÁ•ûÁªèÁΩëÁªú")
        use_gcn = st.checkbox("üîó GCN", value=False, help="ÂõæÂç∑ÁßØÁ•ûÁªèÁΩëÁªú")

        selected_models = []
        if use_attentivefp:
            selected_models.append('attentivefp')
        if use_gcn:
            selected_models.append('gcn')

    # ‰∏ªÊ†áÁ≠æÈ°µ
    main_tabs = st.tabs(["üîç È¢ÑÊµãÂàÜÊûê", "üóÉÔ∏è Êï∞ÊçÆÂ∫ìÊµèËßà"])

    # È¢ÑÊµãÂàÜÊûêÊ†áÁ≠æÈ°µ
    with main_tabs[0]:
        # ‰∏ªÂÜÖÂÆπÂå∫Âüü
        col1, col2 = st.columns([2, 1])

        with col1:
            st.markdown("### üìù ËæìÂÖ•SMILES")
            example_smiles = "CC(=O)Oc1ccccc1C(=O)O"

            smiles_input = st.text_area(
                "ËØ∑ËæìÂÖ•SMILESÂ≠óÁ¨¶‰∏≤ÔºàÊØèË°å‰∏Ä‰∏™Ôºâ",
                height=120,
                placeholder=f"Á§∫‰æãÔºö{example_smiles}\nÂèØËæìÂÖ•Â§ö‰∏™ÂàÜÂ≠ê..."
            )

        with col2:
            st.markdown("### üöÄ Êìç‰Ωú")
            st.markdown("""
            <div class="info-alert">
                üí° <strong>‰ΩøÁî®ÊèêÁ§∫Ôºö</strong><br>
                ‚Ä¢ ÊØèË°åËæìÂÖ•‰∏Ä‰∏™SMILES<br>
                ‚Ä¢ ‰ºòÂÖàÊü•ÊâæÂÆûÈ™åÊï∞ÊçÆ<br>
                ‚Ä¢ ÊîØÊåÅÂ§öÊ®°ÂûãÂØπÊØî<br>
            </div>
            """, unsafe_allow_html=True)

        # È¢ÑÊµãÊåâÈíÆ
        predict_button = st.button("üîç ÂºÄÂßãÈ¢ÑÊµã", type="primary", use_container_width=True)

        # È¢ÑÊµãÈÄªËæë
        if predict_button:
            if smiles_input and (selected_models or use_database):
                with st.spinner('üîÑ Ê≠£Âú®ËøõË°åÈ¢ÑÊµãÂàÜÊûê...'):
                    smiles_list = [s.strip() for s in smiles_input.split('\n') if s.strip()]
                    results = predict_with_multiple_models(smiles_list, selected_models, database if use_database else None)

                    # Â≠òÂÇ®ÁªìÊûúÂà∞session state
                    st.session_state.prediction_results = results
                    st.session_state.selected_models_state = selected_models
                    st.session_state.use_database_state = use_database

                    # ÁªüËÆ°‰ø°ÊÅØ
                    st.markdown("### üìä È¢ÑÊµãÁªüËÆ°")
                    db_count = sum(1 for r in results if r['source'] == 'database')
                    ml_count = sum(1 for r in results if r['source'] == 'ml_models')

                    stat_cols = st.columns(4)
                    with stat_cols[0]:
                        st.markdown(f"""
                        <div class="metric-container">
                            <h3>{len(results)}</h3>
                            <p>ÊÄªÂåñÂêàÁâ©Êï∞</p>
                        </div>
                        """, unsafe_allow_html=True)

                    with stat_cols[1]:
                        st.markdown(f"""
                        <div class="metric-container">
                            <h3>{db_count}</h3>
                            <p>Êï∞ÊçÆÂ∫ìÂåπÈÖç</p>
                        </div>
                        """, unsafe_allow_html=True)

                    with stat_cols[2]:
                        st.markdown(f"""
                        <div class="metric-container">
                            <h3>{ml_count}</h3>
                            <p>Ê®°ÂûãÈ¢ÑÊµã</p>
                        </div>
                        """, unsafe_allow_html=True)

                    with stat_cols[3]:
                        accuracy = f"{(db_count / len(results) * 100):.1f}%" if results else "0%"
                        st.markdown(f"""
                        <div class="metric-container">
                            <h3>{accuracy}</h3>
                            <p>Êï∞ÊçÆÂ∫ìË¶ÜÁõñÁéá</p>
                        </div>
                        """, unsafe_allow_html=True)

                    # ËØ¶ÁªÜÁªìÊûúÂ±ïÁ§∫
                    st.markdown("### üß™ ËØ¶ÁªÜÈ¢ÑÊµãÁªìÊûú")

                    for i, result in enumerate(results):
                        with st.container():
                            st.markdown(f"""
                            <div class="result-card">
                                <div class="compound-title">ÂåñÂêàÁâ© #{i + 1}</div>
                                <p><strong>SMILES:</strong> <code>{result['smiles']}</code></p>
                            </div>
                            """, unsafe_allow_html=True)

                            # È¢ÑÊµãÁªìÊûúÂ±ïÁ§∫
                            result_cols = []

                            if use_database and result['database'] is not None:
                                result_cols.append(("Êï∞ÊçÆÂ∫ìÂÆûÈ™åÂÄº", result['database'], result.get('solvent', 'N/A')))

                            for model in selected_models:
                                pred_key = f'{model}_prediction'
                                if result.get(pred_key) is not None:
                                    result_cols.append((f"{model.upper()}È¢ÑÊµã", result[pred_key], "DLÊ®°Âûã"))

                            if result_cols:
                                cols = st.columns(len(result_cols))
                                for j, (col, (method, value, source)) in enumerate(zip(cols, result_cols)):
                                    with col:
                                        try:
                                            value_float = float(value)
                                            color = "#2D5016" if "Êï∞ÊçÆÂ∫ì" in method else "#667eea"
                                            st.markdown(f"""
                                            <div style="text-align: center; padding: 1rem; 
                                                       background: linear-gradient(135deg, {color}20, {color}10); 
                                                       border-radius: 8px; border: 2px solid {color};">
                                                <div class="model-badge" style="background: {color};">{method}</div>
                                                <div class="prediction-value" style="color: {color};">{value_float:.2f} ppm</div>
                                                <small style="color: #666;">Ê∫∂ÂâÇ: {source}</small>
                                            </div>
                                            """, unsafe_allow_html=True)
                                        except (ValueError, TypeError):
                                            st.error(f"È¢ÑÊµãÈîôËØØ: {value}")

                            # ÊòæÁ§∫È¢ùÂ§ñ‰ø°ÊÅØ
                            if result.get('additional_info') and any(result['additional_info'].values()):
                                with st.expander("üìã ËØ¶ÁªÜ‰ø°ÊÅØ"):
                                    info = result['additional_info']
                                    info_cols = st.columns(3)
                                    with info_cols[0]:
                                        if info.get('MW'):
                                            st.write(f"**ÂàÜÂ≠êÈáè:** {info['MW']}")
                                        if info.get('P_oxidation_state'):
                                            st.write(f"**PÊ∞ßÂåñÊÄÅ:** {info['P_oxidation_state']}")
                                    with info_cols[1]:
                                        if info.get('P_valence'):
                                            st.write(f"**P‰ª∑ÊÄÅ:** {info['P_valence']}")
                                        if info.get('envlab'):
                                            st.write(f"**ÁéØÂ¢ÉÊ†áÁ≠æ:** {info['envlab']}")
                                    with info_cols[2]:
                                        if info.get('num'):
                                            st.write(f"**ÁºñÂè∑:** {info['num']}")

            else:
                st.warning("ËØ∑ËæìÂÖ•SMILESÂπ∂ÈÄâÊã©Ëá≥Â∞ë‰∏ÄÁßçÈ¢ÑÊµãÊñπÊ≥ï")

        # ÂèØËßÜÂåñÈÉ®ÂàÜ
        if hasattr(st.session_state, 'prediction_results'):
            st.markdown("---")
            st.markdown("### üìà ÂèØËßÜÂåñÂàÜÊûê")

            viz_tabs = st.tabs(["üåä NMRË∞±Âõæ", "üìã Êï∞ÊçÆË°®Ê†º"])

            with viz_tabs[0]:
                st.markdown("#### ¬≥¬πP NMR ÂåñÂ≠¶‰ΩçÁßªË∞±Âõæ")

                # ‰ΩøÁî®‰ºòÂåñÁöÑNMRË∞±ÂõæÈÖçÁΩÆ
                plot_config = {
                    'peak_width': 0.04,
                    'show_annotations': True,
                    'plot_style': "professional"
                }

                nmr_fig = create_enhanced_nmr_plot(
                    st.session_state.prediction_results,
                    st.session_state.selected_models_state,
                    st.session_state.use_database_state,
                    plot_config
                )

                if nmr_fig:
                    st.plotly_chart(nmr_fig, use_container_width=True)

                    # Ë∞±ÂõæËØ¥Êòé
                    st.markdown("""
                    <div class="info-alert">
                        <strong>Ë∞±ÂõæËØ¥ÊòéÔºö</strong><br>
                        ‚Ä¢ XËΩ¥ÔºöÂåñÂ≠¶‰ΩçÁßª (ppm)ÔºåÊåâNMR‰π†ÊÉØ‰ªéÂè≥Âà∞Â∑¶ÊéíÂàó<br>
                        ‚Ä¢ YËΩ¥ÔºöÁõ∏ÂØπÂº∫Â∫¶ÔºåÂ≥∞È´ò‰ª£Ë°®‰ø°Âè∑Âº∫Â∫¶<br>
                        ‚Ä¢ ‰∏çÂêåÈ¢úËâ≤‰ª£Ë°®‰∏çÂêåÁöÑÈ¢ÑÊµãÊñπÊ≥ï<br>
                        ‚Ä¢ Èº†Ê†áÊÇ¨ÂÅúÂèØÊü•ÁúãËØ¶ÁªÜ‰ø°ÊÅØ
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.warning("Êó†Ê≥ïÁîüÊàêNMRË∞±ÂõæÔºåËØ∑Ê£ÄÊü•È¢ÑÊµãÁªìÊûú")

            with viz_tabs[1]:
                st.markdown("#### È¢ÑÊµãÁªìÊûúÊï∞ÊçÆË°®Ê†º")

                # ÂàõÂª∫ËØ¶ÁªÜÁöÑÊï∞ÊçÆË°®Ê†º
                table_data = []
                for i, result in enumerate(st.session_state.prediction_results):
                    row = {
                        'ÂåñÂêàÁâ©ID': f'ÂåñÂêàÁâ© {i + 1}',
                        'SMILES': result['smiles'],
                        'Êï∞ÊçÆÊù•Ê∫ê': 'Êï∞ÊçÆÂ∫ì' if result['source'] == 'database' else 'DLÊ®°Âûã'
                    }

                    if st.session_state.use_database_state and result.get('database') is not None:
                        row['Êï∞ÊçÆÂ∫ìÂÆûÈ™åÂÄº (ppm)'] = result['database']
                        row['Ê∫∂ÂâÇ'] = result.get('solvent', 'N/A')

                    for model in st.session_state.selected_models_state:
                        pred_key = f'{model}_prediction'
                        if result.get(pred_key) is not None:
                            try:
                                row[f'{model.upper()}È¢ÑÊµã (ppm)'] = f"{float(result[pred_key]):.2f}"
                            except (ValueError, TypeError):
                                row[f'{model.upper()}È¢ÑÊµã (ppm)'] = "ÈîôËØØ"

                    table_data.append(row)

                if table_data:
                    df_display = pd.DataFrame(table_data)
                    st.dataframe(df_display, use_container_width=True)

                    # ÂØºÂá∫ÂäüËÉΩ
                    csv_data = df_display.to_csv(index=False)
                    st.download_button(
                        label="üìÅ ‰∏ãËΩΩCSVÊñá‰ª∂",
                        data=csv_data,
                        file_name="chemical_shift_predictions.csv",
                        mime="text/csv"
                    )

    # Êï∞ÊçÆÂ∫ìÊµèËßàÊ†áÁ≠æÈ°µ
    with main_tabs[1]:
        st.markdown("### üóÉÔ∏è Êï∞ÊçÆÂ∫ìÊµèËßà‰∏éÊ£ÄÁ¥¢")

        if database is not None:
            st.markdown(f"""
            <div class="info-alert">
                üìä <strong>Êï∞ÊçÆÂ∫ìÁªüËÆ°‰ø°ÊÅØ</strong><br>
                ‚Ä¢ ÊÄªËÆ∞ÂΩïÊï∞: {len(database)}<br>
                ‚Ä¢ ÂåñÂ≠¶‰ΩçÁßªËåÉÂõ¥: {database['shift'].min():.1f} - {database['shift'].max():.1f} ppm<br>
                ‚Ä¢ Âπ≥ÂùáÂåñÂ≠¶‰ΩçÁßª: {database['shift'].mean():.1f} ppm
            </div>
            """, unsafe_allow_html=True)

            # Êï∞ÊçÆÂ∫ìÊêúÁ¥¢ÂäüËÉΩ
            st.markdown("##### üîç ÊêúÁ¥¢‰∏éÁ≠õÈÄâ")
            search_col1, search_col2 = st.columns(2)

            with search_col1:
                search_smiles = st.text_input("ÊåâSMILESÊêúÁ¥¢", placeholder="ËæìÂÖ•SMILESÂ≠óÁ¨¶‰∏≤")
            with search_col2:
                shift_range = st.slider("ÂåñÂ≠¶‰ΩçÁßªËåÉÂõ¥ (ppm)",
                                        float(database['shift'].min()),
                                        float(database['shift'].max()),
                                        (float(database['shift'].min()), float(database['shift'].max())))

            # ËøáÊª§Êï∞ÊçÆÂ∫ì
            filtered_db = database.copy()

            if search_smiles:
                filtered_db = filtered_db[
                    filtered_db['cansmi'].str.contains(search_smiles, case=False, na=False)]

            filtered_db = filtered_db[(filtered_db['shift'] >= shift_range[0]) &
                                      (filtered_db['shift'] <= shift_range[1])]

            st.markdown(f"##### üìã ÊêúÁ¥¢ÁªìÊûú ({len(filtered_db)} Êù°ËÆ∞ÂΩï)")

            if len(filtered_db) > 0:
                # ÊòæÁ§∫Á≠õÈÄâÂêéÁöÑÊï∞ÊçÆ
                display_columns = ['cansmi', 'shift', 'LM', 'MW', 'P_oxidation_state', 'P_valence', 'envlab']
                available_columns = [col for col in display_columns if col in filtered_db.columns]

                # ÈáçÂëΩÂêçÂàóÂêç‰∏∫‰∏≠Êñá
                column_names = {
                    'cansmi': 'SMILES',
                    'shift': 'ÂåñÂ≠¶‰ΩçÁßª (ppm)',
                    'LM': 'Ê∫∂ÂâÇ',
                    'MW': 'ÂàÜÂ≠êÈáè',
                    'P_oxidation_state': 'PÊ∞ßÂåñÊÄÅ',
                    'P_valence': 'P‰ª∑ÊÄÅ',
                    'envlab': 'ÁéØÂ¢ÉÊ†áÁ≠æ'
                }

                display_df = filtered_db[available_columns].rename(columns=column_names)

                # ÂàÜÈ°µÊòæÁ§∫
                page_size = 20
                total_pages = (len(display_df) - 1) // page_size + 1

                if total_pages > 1:
                    page_num = st.selectbox("ÈÄâÊã©È°µÈù¢", range(1, total_pages + 1)) - 1
                    start_idx = page_num * page_size
                    end_idx = start_idx + page_size
                    display_df = display_df.iloc[start_idx:end_idx]

                st.dataframe(display_df, use_container_width=True)

                # Êï∞ÊçÆÂ∫ìÁªüËÆ°ÂõæË°®
                st.markdown("##### üìä Êï∞ÊçÆÂàÜÂ∏ÉÂõæ")

                chart_col1, chart_col2 = st.columns(2)

                with chart_col1:
                    # ÂåñÂ≠¶‰ΩçÁßªÂàÜÂ∏ÉÁõ¥ÊñπÂõæ
                    import plotly.graph_objects as go
                    fig_hist = go.Figure()
                    fig_hist.add_trace(go.Histogram(
                        x=filtered_db['shift'],
                        nbinsx=30,
                        name='ÂåñÂ≠¶‰ΩçÁßªÂàÜÂ∏É',
                        marker_color='#667eea',
                        opacity=0.8
                    ))
                    fig_hist.update_layout(
                        title='ÂåñÂ≠¶‰ΩçÁßªÂàÜÂ∏É',
                        xaxis_title='ÂåñÂ≠¶‰ΩçÁßª (ppm)',
                        yaxis_title='È¢ëÊ¨°',
                        height=400,
                        plot_bgcolor='white'
                    )
                    st.plotly_chart(fig_hist, use_container_width=True)

                with chart_col2:
                    # Ê∫∂ÂâÇÂàÜÂ∏ÉÈ•ºÂõæ
                    if 'LM' in filtered_db.columns:
                        solvent_counts = filtered_db['LM'].value_counts().head(10)
                        fig_pie = go.Figure(data=[go.Pie(
                            labels=solvent_counts.index,
                            values=solvent_counts.values,
                            marker_colors=['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe']
                        )])
                        fig_pie.update_layout(
                            title='Ê∫∂ÂâÇÂàÜÂ∏É (Ââç10Áßç)',
                            height=400
                        )
                        st.plotly_chart(fig_pie, use_container_width=True)

                # ÂØºÂá∫Á≠õÈÄâÁªìÊûú
                csv_filtered = display_df.to_csv(index=False)
                st.download_button(
                    label="üìÅ ‰∏ãËΩΩÁ≠õÈÄâÁªìÊûú",
                    data=csv_filtered,
                    file_name=f"filtered_database_{len(display_df)}_records.csv",
                    mime="text/csv"
                )

            else:
                st.warning("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑËÆ∞ÂΩïÔºåËØ∑Ë∞ÉÊï¥ÊêúÁ¥¢Êù°‰ª∂")
        else:
            st.error("Êï∞ÊçÆÂ∫ìÊú™Âä†ËΩΩÔºåÊó†Ê≥ïÊµèËßàÊï∞ÊçÆ")

    # È°µÈù¢Â∫ïÈÉ®‰ø°ÊÅØ
    st.markdown("---")
    st.markdown("""
    <div style="text-align: center; padding: 2rem; color: #666;">
        <h4>üß™ ÂÖ≥‰∫éÊú¨Âπ≥Âè∞</h4>
        <p>Êú¨Âπ≥Âè∞‰ΩøÁî®ÂÖàËøõÁöÑÂõæÁ•ûÁªèÁΩëÁªúÊäÄÊúØÈ¢ÑÊµã¬≥¬πP NMRÂåñÂ≠¶‰ΩçÁßªÔºåÁªìÂêàÂÆûÈ™åÊï∞ÊçÆÂ∫ì‰∏∫ÂåñÂ≠¶Á†îÁ©∂Êèê‰æõÂáÜÁ°Æ„ÄÅÂø´ÈÄüÁöÑÈ¢ÑÊµãÊúçÂä°„ÄÇ</p>
        <div style="margin-top: 1rem;">
            <span class="model-badge" style="background: #2E86AB;">AttentiveFPÊ®°Âûã</span>
            <span class="model-badge" style="background: #A23B72;">GCNÊ®°Âûã</span>
            <span class="model-badge" style="background: #2D5016;">ÂÆûÈ™åÊï∞ÊçÆÂ∫ì</span>
        </div>
    </div>
    """, unsafe_allow_html=True)


if __name__ == "__main__":
    main()